#!/usr/bin/env node

/**
 * Figma Tokens Sync Script
 * Syncs design tokens from Figma to the codebase
 * 
 * Usage:
 * 1. Set FIGMA_ACCESS_TOKEN in .env
 * 2. Set FIGMA_FILE_KEY in .env
 * 3. Run: node scripts/sync-figma-tokens.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables
const FIGMA_ACCESS_TOKEN = process.env.FIGMA_ACCESS_TOKEN || process.env.VITE_FIGMA_ACCESS_TOKEN;
const FIGMA_FILE_KEY = process.env.FIGMA_FILE_KEY || process.env.VITE_FIGMA_FILE_KEY;

if (!FIGMA_ACCESS_TOKEN || !FIGMA_FILE_KEY) {
  console.error('‚ùå Missing required environment variables:');
  console.error('   - FIGMA_ACCESS_TOKEN');
  console.error('   - FIGMA_FILE_KEY');
  console.error('\nAdd these to your .env file.');
  process.exit(1);
}

/**
 * Fetch Figma file data
 */
async function fetchFigmaFile() {
  console.log('üì° Fetching Figma file...');
  
  const response = await fetch(
    `https://api.figma.com/v1/files/${FIGMA_FILE_KEY}`,
    {
      headers: {
        'X-Figma-Token': FIGMA_ACCESS_TOKEN,
      },
    }
  );

  if (!response.ok) {
    throw new Error(`Figma API error: ${response.status} ${response.statusText}`);
  }

  return await response.json();
}

/**
 * Fetch Figma styles (colors, text styles, effects)
 */
async function fetchFigmaStyles() {
  console.log('üé® Fetching Figma styles...');
  
  const response = await fetch(
    `https://api.figma.com/v1/files/${FIGMA_FILE_KEY}/styles`,
    {
      headers: {
        'X-Figma-Token': FIGMA_ACCESS_TOKEN,
      },
    }
  );

  if (!response.ok) {
    throw new Error(`Figma API error: ${response.status} ${response.statusText}`);
  }

  return await response.json();
}

/**
 * Parse Figma color to Tailwind format
 */
function parseColor(color) {
  const r = Math.round(color.r * 255);
  const g = Math.round(color.g * 255);
  const b = Math.round(color.b * 255);
  const a = color.a !== undefined ? color.a : 1;
  
  if (a === 1) {
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`.toUpperCase();
  } else {
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }
}

/**
 * Extract design tokens from Figma file
 */
function extractTokens(figmaData, stylesData) {
  console.log('üîç Extracting design tokens...');
  
  const tokens = {
    colors: {},
    typography: {},
    spacing: {},
    effects: {},
  };

  // Extract colors from styles
  if (stylesData.meta && stylesData.meta.styles) {
    stylesData.meta.styles.forEach(style => {
      if (style.style_type === 'FILL') {
        // This is a color style
        const name = style.name.toLowerCase().replace(/\s+/g, '-');
        // Note: Actual color values would need to be fetched from nodes
        tokens.colors[name] = {
          name: style.name,
          key: style.key,
          description: style.description || '',
        };
      } else if (style.style_type === 'TEXT') {
        // This is a text style
        const name = style.name.toLowerCase().replace(/\s+/g, '-');
        tokens.typography[name] = {
          name: style.name,
          key: style.key,
          description: style.description || '',
        };
      } else if (style.style_type === 'EFFECT') {
        // This is an effect style (shadows, blurs)
        const name = style.name.toLowerCase().replace(/\s+/g, '-');
        tokens.effects[name] = {
          name: style.name,
          key: style.key,
          description: style.description || '',
        };
      }
    });
  }

  return tokens;
}

/**
 * Generate Tailwind config from tokens
 */
function generateTailwindConfig(tokens) {
  console.log('‚öôÔ∏è  Generating Tailwind config...');
  
  const config = {
    colors: {},
    fontSize: {},
    boxShadow: {},
  };

  // Map colors
  Object.entries(tokens.colors).forEach(([key, value]) => {
    config.colors[key] = value.value || '#000000';
  });

  return config;
}

/**
 * Generate design tokens TypeScript file
 */
function generateDesignTokensFile(tokens) {
  console.log('üìù Generating design-tokens.ts...');
  
  const content = `/**
 * Design Tokens - Synced from Figma
 * Last synced: ${new Date().toISOString()}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Run: npm run sync:figma to update
 */

// Colors from Figma
export const figmaColors = ${JSON.stringify(tokens.colors, null, 2)};

// Typography from Figma
export const figmaTypography = ${JSON.stringify(tokens.typography, null, 2)};

// Effects from Figma
export const figmaEffects = ${JSON.stringify(tokens.effects, null, 2)};

// Spacing from Figma
export const figmaSpacing = ${JSON.stringify(tokens.spacing, null, 2)};
`;

  const outputPath = path.join(__dirname, '..', 'design-tokens-figma.ts');
  fs.writeFileSync(outputPath, content, 'utf-8');
  
  console.log(`‚úÖ Generated: ${outputPath}`);
}

/**
 * Main sync function
 */
async function syncFigmaTokens() {
  try {
    console.log('üöÄ Starting Figma tokens sync...\n');

    // Fetch data from Figma
    const [figmaFile, figmaStyles] = await Promise.all([
      fetchFigmaFile(),
      fetchFigmaStyles(),
    ]);

    // Extract tokens
    const tokens = extractTokens(figmaFile, figmaStyles);

    // Generate files
    generateDesignTokensFile(tokens);

    console.log('\n‚úÖ Figma tokens sync completed successfully!');
    console.log('\nüìä Summary:');
    console.log(`   - Colors: ${Object.keys(tokens.colors).length}`);
    console.log(`   - Typography: ${Object.keys(tokens.typography).length}`);
    console.log(`   - Effects: ${Object.keys(tokens.effects).length}`);
    console.log(`   - Spacing: ${Object.keys(tokens.spacing).length}`);
    
  } catch (error) {
    console.error('\n‚ùå Error syncing Figma tokens:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  syncFigmaTokens();
}

export { syncFigmaTokens };

